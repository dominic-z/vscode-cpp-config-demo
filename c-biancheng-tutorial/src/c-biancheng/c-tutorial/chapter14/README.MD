# 14.3
CPU一个时钟周期能处理的数据的大小由寄存器的位数和数据总线的最大根数（两者相等）决定，这个指的就是cpu的位数
个人理解，这个东西的含义就是，cpu能处理多大的数据（cpu位数）和内存一次能够往cpu传多少数据（总线根数）。而地址总线是用来定位数据，用来从内存里找数据，比如地址总线20根，每个地址的位数就是20位，所以寻址能力就是$2^20$，就是1MB的内存（每个地址都指向了一个byte的数据，一共2^20个byte，就是1MB=2^20B）
[数据总线和地址总线区别是什么?作用分别是什么](https://blog.csdn.net/qq_39759656/article/details/81700114)

# 14.4
内存对齐指的就是数据都是从4的倍数开始的，没对齐举个例子就是，一个int是4个字节，存到了内存中的10~13，那么就要先读一次8~12再读一次12~16才行

# 14.5
他们是如何共享一个PP的，我猜是如果某个PP被program1占用，但这时候program2要用到这个PP，那么这个PP就会被写到DP里，这样这个PP就空出来了，就被program2用起来了

# 14.6
## 数组映射
虚拟地址4B，每个虚拟地址对应1个大小为4B的真实地址，一共2^32个虚拟地址，需要2^34B，就是16GB数据
(此处的小问题，那虚拟地址怎么存呢，虚拟地址也有2^32个取值，那也是需要16GB来存储虚拟地址，所以我猜，并不是需要存储全部的虚拟地址的)


## 一级页表
页表：一个共1M个元素、占用内存4mb的列表，每个元素储存了物理页的内存地址以及相关信息
虚拟地址高20位用来指代页表数组的下标，低12位用来指代页内偏移
页表数组每个数字高20位用来指代物理页的内存地址，低12位用来存储信息
相较于直接使用数组转换，这样设计两个虚拟地址可能指向的页表数组的同一个元素

## 二级页表
这里设计了两个页表，一级页表用来存二级页表列表的偏移，二级页表用于存储物理
一级页表：一个共1k个元素、占用内存为4kb的列表，每个元素对应了一个二级页表
二级页表：一个共1k个元素、占用内存4kb的列表，每个元素对应了一个物理页的地址以及相关信息
这样设计的优点，二级页表设计中，二级页表的数目可变，也就是说以及页表的元素数目不固定。占用内存少，一级页表中元素数目就少。(那为啥不把一级页表也设计成可伸缩的？)

# 14.7
## MMU
MMU里有一个缓存，用来存页目录和页表，而CR3这个寄存器存的就是页目录的地址。

# 14.8
## 一个实例
```c
#include<stdio.h>

char *str1="c.biancheng.net";// 字符串在常量区，str1在全局数据区
int n; // 全局数据区

char *func(){
    char *str="c语言中文网"; // 字符串在常量区，str在栈
    char stack_strs[20]="56789"; // 字符串和arr都在栈，如果返回arr，则main函数里最后一个print会失效
    return str;
}

int main(){
    int a;
    char *str2="01234"; // 字符串在常量区，str2在栈区
    char arr[20]="56789"; // 字符串和arr都在栈
    char *pstr=func(); // pstr在栈
    int b; // b在栈

    printf("str1:%#X\npstr: %#X\nstr2:%#X\n",str1,pstr,str2);
    printf("---------------------\n");
    printf("&str1:%#X\n&n: %#X\n",&str1,&n);
    printf("---------------------\n");
    printf("&a:%#X\narr: %#X\n&b:%#X\n",&a,arr,&b);
    printf("---------------------\n");
    printf("n:%d\na: %d\nb:%d\n",n,a,b);
    printf("---------------------\n");
    printf("%s\n",pstr);
    return 0;
}
```
1. func函数里str是在栈，但这个字符串是存在常量区，而main函数调用的时候，该函数在返回的时候会将指针的值赋值为main里的pstr，然后str被销毁，但是这个字符串还在。因此仍然可访问。但如果返回`stack_strs`，由于其指向的字符串存在栈，返回时会被销毁，因此这时最后的print就打印不出来结果了